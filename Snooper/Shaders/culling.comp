layout(local_size_x = 64) in;

struct PrimitiveDescriptor
{
    vec3 center;
    vec3 extents;
    uint maxLod;
    uvec4 firstIndex[2]; // EBO offsets for each LOD
    uvec4 baseVertex[2]; // VBO offsets for each LOD
    uvec4 sectionCount[2]; // number of sections for each LOD
    uvec4 sectionOffset[2]; // section offsets for each LOD in SectionDescriptorsBuffer
};

struct SectionDescriptor
{
    uint firstIndex;
    uint count;
    uint materialIndex;
};

struct PerInstanceData
{
    mat4 matrix;
};

struct DrawElementsIndirectCommand // 1 draw command per section per model in LOD 0
{
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
    uint originalInstanceCount;
    uint originalBaseInstance;
    uint modelId; // model offset in PrimitiveDescriptorsBuffer
    uint sectionId; // section index in the current model (0-X)
};

layout(std430, binding = 0) readonly buffer PerInstanceDataBuffer
{
    PerInstanceData uInstanceDataBuffer[];
};

layout(std430, binding = 1) readonly buffer PrimitiveDescriptorsBuffer
{
    PrimitiveDescriptor uPrimitiveDescriptors[];
};

layout(std430, binding = 2) buffer SectionDescriptorsBuffer
{
    SectionDescriptor uSectionDescriptors[];
};

layout(std430, binding = 3) buffer DrawCommandBuffer
{
    DrawElementsIndirectCommand uIndirectDrawCommands[];
};

uniform vec4 uFrustumPlanes[6];
uniform vec3 uCameraPosition;

bool isVisible(vec3 center, vec3 extents)
{
    bool isInside = true;
    for (int i = 0; i < 6; ++i)
    {
        vec4 plane = uFrustumPlanes[i];
        vec3 normal = plane.xyz;
        float d = plane.w;
        
        float r = dot(abs(normal), extents);
        float s = dot(normal, center) + d;
        if (s < -r)
        {
            isInside = false;
            break;
        }
    }
    
    return isInside;
}

bool equals(DrawElementsIndirectCommand a, DrawElementsIndirectCommand b)
{
    return
        a.baseInstance == b.baseInstance &&
        a.instanceCount == b.instanceCount &&
        a.count == b.count &&
        a.firstIndex == b.firstIndex &&
        a.baseVertex == b.baseVertex;
}

void main()
{
    uint drawId = gl_GlobalInvocationID.x;
    if (drawId >= uIndirectDrawCommands.length()) return;

    DrawElementsIndirectCommand cmd = uIndirectDrawCommands[drawId];
    PrimitiveDescriptor primitive = uPrimitiveDescriptors[cmd.modelId];
    uint instanceCount = cmd.originalInstanceCount;
    uint baseInstance = cmd.originalBaseInstance;

    uint minVisible = 0xFFFFFFFFu;
    uint maxVisible = 0;
    float closestDistance = 3.402823e+38;
    for (uint j = 0; j < instanceCount; ++j)
    {
        mat4 modelMatrix = uInstanceDataBuffer[baseInstance + j].matrix;

        vec3 worldCenter = (modelMatrix * vec4(primitive.center, 1.0)).xyz;
        mat3 m = mat3(modelMatrix);
        vec3 worldExtents = vec3(
            dot(abs(m[0]), primitive.extents),
            dot(abs(m[1]), primitive.extents),
            dot(abs(m[2]), primitive.extents)
        );

        if (isVisible(worldCenter, worldExtents))
        {
            minVisible = min(minVisible, j);
            maxVisible = max(maxVisible, j);

            float dist = length(uCameraPosition - worldCenter);
            if (dist < closestDistance)
            {
                closestDistance = dist;
            }
        }
    }

    DrawElementsIndirectCommand newCmd = cmd;
    if (minVisible <= maxVisible)
    {
        newCmd.baseInstance = baseInstance + minVisible;
        newCmd.instanceCount = maxVisible - minVisible + 1;
        
        // if primitive has at least 2 lods, switch based on distance (for now)
        if (primitive.maxLod > 0)
        {
            uint lod = uint(floor(log2(closestDistance / 100.0))); // basic example
            lod = clamp(lod, 0u, primitive.maxLod);
            uint lodGroup = lod / 4;
            uint lodSub = lod % 4;

            uint sectionCount = primitive.sectionCount[lodGroup][lodSub];
            if (cmd.sectionId >= sectionCount)
            {
                newCmd.instanceCount = 0;
            }
            else
            {
                uint sectionOffset = primitive.sectionOffset[lodGroup][lodSub] + cmd.sectionId;
                SectionDescriptor section = uSectionDescriptors[sectionOffset];
                
                newCmd.count = section.count;
                newCmd.firstIndex = primitive.firstIndex[lodGroup][lodSub] + section.firstIndex;
                newCmd.baseVertex = primitive.baseVertex[lodGroup][lodSub];
            }
        }
    }
    else
    {
        newCmd.instanceCount = 0;
    }
    
    if (!equals(cmd, newCmd))
    {
        uIndirectDrawCommands[drawId].count         = newCmd.count;
        uIndirectDrawCommands[drawId].instanceCount = newCmd.instanceCount;
        uIndirectDrawCommands[drawId].firstIndex    = newCmd.firstIndex;
        uIndirectDrawCommands[drawId].baseVertex    = newCmd.baseVertex;
        uIndirectDrawCommands[drawId].baseInstance  = newCmd.baseInstance;
    }
}
